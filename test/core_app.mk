# Core: Building applications.

CORE_APP_CASES = appsrc-change asn1 auto-git-id env erlc-exclude erlc-opts erlc-opts-filter error extra-keys generate-erl generate-erl-include generate-erl-prepend hrl hrl-recursive makefile-change mib name-special-char no-app no-makedep project-mod pt pt-erlc-opts xrl xrl-include yrl yrl-header yrl-include
CORE_APP_TARGETS = $(addprefix core-app-,$(CORE_APP_CASES))

.PHONY: core-app $(CORE_APP_TARGETS)

core-app: $(CORE_APP_TARGETS)

ifdef LEGACY
core-app-appsrc-change: build clean

	$i "Bootstrap a new OTP application named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap $v

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Touch the .app.src file; check that only the .app file gets rebuilt"
	$t printf "%s\n" $(APP)/ebin/$(APP).app > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/src/$(APP).app.src
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/$(APP).app.src | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT
endif

core-app-asn1: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download .asn1 files from Erlang/OTP"
	$t mkdir $(APP)/asn1/
	$t curl -s -o $(APP)/asn1/CAP.asn1 $(OTP_MASTER)/lib/asn1/test/asn1_SUITE_data/CAP.asn1
	$t curl -s -o $(APP)/asn1/Def.asn1 $(OTP_MASTER)/lib/asn1/test/asn1_SUITE_data/Def.asn1

	$i "Generate .erl files dependent from headers generated by .asn1 files"
	$t printf "%s\n" "-module(use_cap)." "-include(\"CAP.hrl\")." > $(APP)/src/use_cap.erl
	$t printf "%s\n" "-module(use_def)." "-include(\"Def.hrl\")." > $(APP)/src/use_def.erl

	$i "Generate an unrelated .hrl file"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/unrelated.hrl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/CAP.beam
	$t test -f $(APP)/ebin/Def.beam
	$t test -f $(APP)/ebin/use_cap.beam
	$t test -f $(APP)/ebin/use_def.beam
	$t test -f $(APP)/include/CAP.asn1db
	$t test -f $(APP)/include/CAP.hrl
	$t test -f $(APP)/include/Def.asn1db
	$t test -f $(APP)/include/Def.hrl
	$t test -f $(APP)/src/CAP.erl
	$t test -f $(APP)/src/Def.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = ['CAP', 'Def', use_cap, use_def]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .asn1 file; check that only required files are rebuilt"
# The use_cap.erl gets touched because of its dependency to CAP.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/CAP.beam \
		$(APP)/ebin/use_cap.beam \
		$(APP)/include/CAP.asn1db \
		$(APP)/include/CAP.hrl \
		$(APP)/src/CAP.erl \
		$(APP)/src/use_cap.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/asn1/CAP.asn1
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/asn1/CAP.asn1 | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = ['CAP', 'Def', use_cap, use_def]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/asn1/CAP.asn1
	$t test -f $(APP)/asn1/Def.asn1
	$t test -f $(APP)/include/unrelated.hrl
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_cap.erl
	$t test -f $(APP)/src/use_def.erl

	$i "Check that all build artifacts are removed, including intermediates"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/
	$t test ! -e $(APP)/include/CAP.asn1db
	$t test ! -e $(APP)/include/CAP.hrl
	$t test ! -e $(APP)/include/Def.asn1db
	$t test ! -e $(APP)/include/Def.hrl
	$t test ! -e $(APP)/src/CAP.erl
	$t test ! -e $(APP)/src/Def.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/CAP.beam
	$t test -f $(APP)/ebin/Def.beam
	$t test -f $(APP)/ebin/use_cap.beam
	$t test -f $(APP)/ebin/use_def.beam
	$t test -f $(APP)/include/CAP.asn1db
	$t test -f $(APP)/include/CAP.hrl
	$t test -f $(APP)/include/Def.asn1db
	$t test -f $(APP)/include/Def.hrl
	$t test -f $(APP)/src/CAP.erl
	$t test -f $(APP)/src/Def.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = ['CAP', 'Def', use_cap, use_def]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Build the application with ERLC_ASN1_OPTS set"
	$t echo "ERLC_ASN1_OPTS += +'{record_name_prefix,\"FOO-\"}'" >> $(APP)/Makefile
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was built with ERLC_ASN1_OPTS set"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
	  Attrs = 'Def':module_info(attributes), \
		Asn1Info = proplists:get_value(asn1_info, Attrs), \
		Opts = proplists:get_value(options, Asn1Info), \
		true = lists:member({record_name_prefix, \"FOO-\"}, Opts), \
		halt()"

core-app-auto-git-id: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Make it a git repository"
	$t cd $(APP) && \
		git init -q && \
		git config user.email "testsuite@erlang.mk" && \
		git config user.name "test suite" && \
		git add . && \
		git commit -q -m "Tests"

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

ifdef LEGACY
# Legacy replaces {id, "git"} always regardless of built as a dependency.
	$i "Check that the generated .app file has an id key"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, ID} = application:get_key($(APP), id), \
		true = ID =/= [], \
		halt()"
else
# If there is no .app.src though, only fill in id when built as a dependency.
	$i "Check that the generated .app file has no id key"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, []} = application:get_key($(APP), id), \
		halt()"
endif

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Build the application with IS_DEP=1"
	$t $(MAKE) -C $(APP) IS_DEP=1 $v

	$i "Check that the generated .app file has an id key"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, ID} = application:get_key($(APP), id), \
		true = ID =/= [], \
		halt()"

ifndef LEGACY
core-app-env: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Define PROJECT_ENV"
	$t echo "PROJECT_ENV = [{test_key, test_value}]" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:load($(APP)), \
		{ok, test_value} = application:get_env($(APP), test_key), \
		halt()"

	$i "Define PROJECT_ENV with escape in string, special char"
	$t echo "PROJECT_ENV = [{test_atom, '\\\$$\$$test'}, {test_key, \"\\\"test_\\tvalue\\\"\"}]" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:load($(APP)), \
		{ok, \"\\\"test_\\tvalue\\\"\"} = application:get_env($(APP), test_key), \
		{ok, '\\\$$test'} = application:get_env($(APP), test_atom), \
		halt()"
endif

core-app-erlc-exclude: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Exclude boy.erl from the compilation"
	$t echo "ERLC_EXCLUDE = boy" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that boy.erl was not compiled"
	$t test ! -e $(APP)/ebin/boy.beam

	$i "Check that the application was compiled correctly (without boy.erl)"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-erlc-opts: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Define an empty ERLC_OPTS (without debug_info)"
	$t echo "ERLC_OPTS =" >> $(APP)/Makefile

	$i "Generate .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly (without debug_info)"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		false = proplists:is_defined(debug_info, proplists:get_value(options, boy:module_info(compile))), \
		false = proplists:is_defined(debug_info, proplists:get_value(options, girl:module_info(compile))), \
		halt()"

core-app-erlc-opts-filter: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Define ERLC_OPTS filtering out debug_info"
	$t echo "ERLC_OPTS := \$$(filter-out +debug_info,\$$(ERLC_OPTS))" >> $(APP)/Makefile

	$i "Generate .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly (without debug_info)"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		false = proplists:is_defined(debug_info, proplists:get_value(options, boy:module_info(compile))), \
		false = proplists:is_defined(debug_info, proplists:get_value(options, girl:module_info(compile))), \
		halt()"

core-app-error: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate a bad .erl files"
	$t touch $(APP)/src/breaking.erl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Check that trying to build returns non-zero"
	$t ! $(MAKE) -C $(APP) $v

ifndef LEGACY
core-app-extra-keys: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Define PROJECT_APP_EXTRA_KEYS"
	$t printf "define PROJECT_APP_EXTRA_KEYS\n\t{maxT, 10000},\n\t{non_standard_key, test_value}\nendef\n" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:load($(APP)), \
		{ok, 10000} = application:get_key($(APP), maxT), \
		AppFile = filename:join(code:lib_dir($(APP), ebin), atom_to_list($(APP)) ++ \".app\"), \
		{ok, [App]} = file:consult(AppFile), \
		{application, $(APP), Props} = App, \
		test_value = proplists:get_value(non_standard_key, Props),\
		halt()"

	$i "Define PROJECT_APP_EXTRA_KEYS with escape in string, special char"
	$t echo "PROJECT_APP_EXTRA_KEYS = {non_standard_atom, '\\\$$\$$my_app'}, {non_standard_string, \"\\\"test_\\tvalue\\\"\"}" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:load($(APP)), \
		AppFile = filename:join(code:lib_dir($(APP), ebin), atom_to_list($(APP)) ++ \".app\"), \
		{ok, [App]} = file:consult(AppFile), \
		{application, $(APP), Props} = App, \
		'\\\$$my_app' = proplists:get_value(non_standard_atom, Props),\
		\"\\\"test_\\tvalue\\\"\" = proplists:get_value(non_standard_string, Props),\
		halt()"
endif

core-app-generate-erl: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Create a fake script file to be used as dependency"
	$t touch $(APP)/script.sh

	$i "Append rules to the Makefile to generate a .erl module"
	$t echo "\$$(PROJECT).d:: src/generated.erl" >> $(APP)/Makefile
	$t echo "src/generated.erl:: script.sh; echo \"-module(generated).\" > \$$@" >> $(APP)/Makefile

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/generated.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/generated.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the script file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/generated.beam \
		$(APP)/src/generated.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/script.sh
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/script.sh | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/script.sh
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/boy.erl
	$t test -f $(APP)/src/girl.erl

	$i "Check that the generated .erl file still exists"
	$t test -f $(APP)/src/generated.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Add a rule to remove the generated .erl file on clean"
	$t echo "clean:: ; rm src/generated.erl" >> $(APP)/Makefile

	$i "Clean the application again"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that the generated .erl file was removed"
	$t test ! -e $(APP)/src/generated.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/generated.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/generated.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-generate-erl-include: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Create a fake script file to be used as dependency"
	$t touch $(APP)/script.sh

	$i "Append rules to the Makefile to generate a .erl module"
	$t echo "\$$(PROJECT).d:: src/generated.erl" >> $(APP)/Makefile
	$t echo "src/generated.erl:: script.sh; echo \"-module(generated).\" > \$$@; echo \"-include(\\\"included.hrl\\\").\" >> \$$@" >> $(APP)/Makefile

	$i "Generate the .hrl file"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/included.hrl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/generated.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/generated.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the .hrl file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/generated.beam \
		$(APP)/src/generated.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/include/included.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/include/included.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-generate-erl-prepend: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Create a fake script file to be used as dependency"
	$t touch $(APP)/script.sh

	$i "Generate a Makefile and prepend rules that generate a .erl module"
	$t echo "PROJECT = $(APP)" > $(APP)/Makefile
	$t echo ".DEFAULT_GOAL = all" >> $(APP)/Makefile
	$t echo "\$$(PROJECT).d:: src/generated.erl" >> $(APP)/Makefile
	$t echo "src/generated.erl:: script.sh; echo \"-module(generated).\" > \$$@" >> $(APP)/Makefile
	$t echo "include erlang.mk" >> $(APP)/Makefile

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/generated.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/generated.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the script file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/generated.beam \
		$(APP)/src/generated.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/script.sh
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/script.sh | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/script.sh
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/boy.erl
	$t test -f $(APP)/src/girl.erl

	$i "Check that the generated .erl file still exists"
	$t test -f $(APP)/src/generated.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Add a rule to remove the generated .erl file on clean"
	$t echo "clean:: ; rm src/generated.erl" >> $(APP)/Makefile

	$i "Clean the application again"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that the generated .erl file was removed"
	$t test ! -e $(APP)/src/generated.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/generated.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/generated.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-hrl: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .hrl files"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/blue.hrl $(APP)/include/red.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include(\"blue.hrl\")." > $(APP)/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include(\"red.hrl\")." > $(APP)/src/use_red.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .hrl file; check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_red.beam \
		$(APP)/src/use_red.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/include/red.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/include/red.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/include/blue.hrl
	$t test -f $(APP)/include/red.hrl
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_blue.erl
	$t test -f $(APP)/src/use_red.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-hrl-recursive: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .hrl files"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/blue.hrl $(APP)/include/pill.hrl
	$t echo "-include(\"pill.hrl\")." > $(APP)/include/red.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include(\"blue.hrl\")." > $(APP)/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include(\"red.hrl\")." > $(APP)/src/use_red.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the deepest .hrl file; check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl and pill.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_red.beam \
		$(APP)/src/use_red.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/include/pill.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/include/pill.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/include/blue.hrl
	$t test -f $(APP)/include/pill.hrl
	$t test -f $(APP)/include/red.hrl
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_blue.erl
	$t test -f $(APP)/src/use_red.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-makefile-change: build clean

	$i "Bootstrap a new OTP application named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap $v

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Touch the Makefile; check that all files get rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/$(APP)_app.beam \
		$(APP)/ebin/$(APP)_sup.beam \
		$(APP)/src/$(APP)_app.erl \
		$(APP)/src/$(APP)_sup.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/Makefile
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/Makefile -not -path "$(APP)/.erlang.mk/*" | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

core-app-mib: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download .mib files from Erlang/OTP"
	$t mkdir $(APP)/mibs/
	$t curl -s -o $(APP)/mibs/EX1-MIB.mib $(OTP_MASTER)/lib/snmp/examples/ex1/EX1-MIB.mib
	$t curl -s -o $(APP)/mibs/OTP-REG.mib $(OTP_MASTER)/lib/otp_mibs/mibs/OTP-REG.mib

	$i "Generate .erl files dependent from headers generated by .mib files"
	$t printf "%s\n" "-module(use_v1)." "-include(\"EX1-MIB.hrl\")." > $(APP)/src/use_v1.erl
	$t printf "%s\n" "-module(use_v2)." "-include(\"OTP-REG.hrl\")." > $(APP)/src/use_v2.erl

	$i "Generate an unrelated .hrl file"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/unrelated.hrl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_v1.beam
	$t test -f $(APP)/ebin/use_v2.beam
	$t test -f $(APP)/include/EX1-MIB.hrl
	$t test -f $(APP)/include/OTP-REG.hrl
	$t test -f $(APP)/priv/mibs/EX1-MIB.bin
	$t test -f $(APP)/priv/mibs/OTP-REG.bin

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_v1, use_v2]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .mib file; check that only required files are rebuilt"
# The use_v1.erl gets touched because of its dependency to EX1-MIB.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_v1.beam \
		$(APP)/include/EX1-MIB.hrl \
		$(APP)/priv/mibs/EX1-MIB.bin \
		$(APP)/src/use_v1.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/mibs/EX1-MIB.mib
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/mibs/EX1-MIB.mib | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_v1, use_v2]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/include/unrelated.hrl
	$t test -f $(APP)/mibs/EX1-MIB.mib
	$t test -f $(APP)/mibs/OTP-REG.mib
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_v1.erl
	$t test -f $(APP)/src/use_v2.erl

	$i "Check that all build artifacts are removed, including intermediates"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/
	$t test ! -e $(APP)/include/EX1-MIB.hrl
	$t test ! -e $(APP)/include/OTP-REG.hrl
	$t test ! -e $(APP)/priv/mibs/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_v1.beam
	$t test -f $(APP)/ebin/use_v2.beam
	$t test -f $(APP)/include/EX1-MIB.hrl
	$t test -f $(APP)/include/OTP-REG.hrl
	$t test -f $(APP)/priv/mibs/EX1-MIB.bin
	$t test -f $(APP)/priv/mibs/OTP-REG.bin

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_v1, use_v2]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

ifndef LEGACY
core-app-name-special-char: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Set PROJECT_DESCRIPTION = test % in the Makefile"
	$t echo "PROJECT_DESCRIPTION = test %" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:load($(APP)), \
		{ok,\"test %\"} = application:get_key($(APP), description), \
		halt()"
endif

core-app-no-app: build clean

	$i "Bootstrap a project without an OTP library"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v
	$t rm -rf $(APP)/src

	$i "Build the project"
	$t $(MAKE) -C $(APP) $v

core-app-no-makedep: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Set NO_MAKEDEP ?= 1 in the Makefile"
	$t perl -ni.bak -e 'print;if ($$.==1) {print "NO_MAKEDEP ?= 1\n"}' $(APP)/Makefile

	$i "Generate .hrl files"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/blue.hrl $(APP)/include/red.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include(\"blue.hrl\")." > $(APP)/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include(\"red.hrl\")." > $(APP)/src/use_red.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .hrl file; check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl.
	$t printf "%s\n" \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_red.beam \
		$(APP)/src/use_red.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/include/red.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/include/red.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .hrl file; disable NO_MAKEDEP and check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_red.beam \
		$(APP)/src/use_red.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/include/red.hrl
	$t $(SLEEP)
	$t NO_MAKEDEP= $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/include/red.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/include/blue.hrl
	$t test -f $(APP)/include/red.hrl
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_blue.erl
	$t test -f $(APP)/src/use_red.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-project-mod: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate an application module"
	$t printf "%s\n" \
		"-module(app_mod)." \
		"-export([start/2, stop/1])." \
		"start(_StartType, _StartArgs) -> {ok, self()}." \
		"stop(_State) -> ok." > $(APP)/src/app_mod.erl

	$i "Build the application with PROJECT_MOD"
	$t $(MAKE) -C $(APP) PROJECT_MOD=app_mod $v

	$i "Check that the application starts correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval "ok = application:start($(APP)), halt()"

core-app-pt: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate a parse_transform module"
	$t printf "%s\n" \
		"-module(my_pt)." \
		"-export([parse_transform/2])." \
		"parse_transform(Forms, _) ->" \
		"	io:format(\"# Running my_pt parse_transform.~n\")," \
		"	Forms." > $(APP)/src/my_pt.erl

	$i "Generate a .erl file that uses the my_pt parse_transform"
	$t printf "%s\n" \
		"-module(my_user)." \
		"-compile({parse_transform, my_pt})." > $(APP)/src/my_user.erl

	$i "Compile my_pt first"
	$t echo "COMPILE_FIRST += my_pt" >> $(APP)/Makefile

	$i "Build the application; confirm the parse_transform is used"
	$t $(MAKE) -C $(APP) | grep "Running my_pt parse_transform."

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [my_pt, my_user]} = application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-pt-erlc-opts: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Bootstrap a new OTP library in $(APP)/deps/my_pt_dep"
	$t mkdir -p $(APP)/deps/my_pt_dep/
	$t cp ../erlang.mk $(APP)/deps/my_pt_dep/
	$t $(MAKE) -C $(APP)/deps/my_pt_dep/ -f erlang.mk bootstrap-lib $v

	$i "Generate a parse_transform module in my_pt_dep"
	$t printf "%s\n" \
		"-module(my_pt)." \
		"-export([parse_transform/2])." \
		"parse_transform(Forms, _) ->" \
		"	io:format(\"# Running my_pt parse_transform.~n\")," \
		"	Forms." > $(APP)/deps/my_pt_dep/src/my_pt.erl

	$i "Add my_pt_dep to the list of dependencies"
	$t perl -ni.bak -e 'print;if ($$.==1) {print "BUILD_DEPS = my_pt_dep\n"}' $(APP)/Makefile

	$i "Generate .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Add the my_pt parse_transform to ERLC_OPTS"
	$t echo "ERLC_OPTS += +'{parse_transform, my_pt}'" >> $(APP)/Makefile

	$i "Build the application; confirm the parse_transform is used"
	$t $(MAKE) -C $(APP) | grep "Running my_pt parse_transform."

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl]} = application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-xrl: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download .xrl files from Robert"
	$t curl -s -o $(APP)/src/erlang_scan.xrl https://raw.githubusercontent.com/rvirding/leex/master/examples/erlang_scan.xrl
	$t curl -s -o $(APP)/src/lfe_scan.xrl https://raw.githubusercontent.com/rvirding/leex/master/examples/lfe_scan.xrl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Disable warnings; our test .xrl files aren't perfect"
	$t echo "ERLC_OPTS=+debug_info" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/erlang_scan.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/lfe_scan.beam
	$t test -f $(APP)/src/erlang_scan.erl
	$t test -f $(APP)/src/lfe_scan.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, erlang_scan, girl, lfe_scan]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .xrl file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/erlang_scan.beam \
		$(APP)/src/erlang_scan.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/src/erlang_scan.xrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/erlang_scan.xrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, erlang_scan, girl, lfe_scan]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/boy.erl
	$t test -f $(APP)/src/erlang_scan.xrl
	$t test -f $(APP)/src/girl.erl
	$t test -f $(APP)/src/lfe_scan.xrl

	$i "Check that all build artifacts are removed, including intermediates"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/
	$t test ! -e $(APP)/src/erlang_scan.erl
	$t test ! -e $(APP)/src/lfe_scan.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/erlang_scan.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/lfe_scan.beam
	$t test -f $(APP)/src/erlang_scan.erl
	$t test -f $(APP)/src/lfe_scan.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, erlang_scan, girl, lfe_scan]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-xrl-include: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download a .xrl file with numerous includes from Gordon"
	$t curl -s -o $(APP)/src/xfl_lexer.xrl https://raw.githubusercontent.com/hypernumbers/hypernumbers/master/lib/formula_engine-1.0/priv/xfl_lexer.xrl
	$t curl -s -o $(APP)/src/errvals.hrl https://raw.githubusercontent.com/hypernumbers/hypernumbers/master/lib/hypernumbers-1.0/include/errvals.hrl
	$t curl -s -o $(APP)/src/muin_proc_dict.hrl https://raw.githubusercontent.com/hypernumbers/hypernumbers/master/lib/hypernumbers-1.0/include/muin_proc_dict.hrl
	$t curl -s -o $(APP)/src/muin_records.hrl https://raw.githubusercontent.com/hypernumbers/hypernumbers/master/lib/hypernumbers-1.0/include/muin_records.hrl
	$t curl -s -o $(APP)/src/typechecks.hrl https://raw.githubusercontent.com/hypernumbers/hypernumbers/master/lib/hypernumbers-1.0/include/typechecks.hrl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Disable warnings; our test .xrl files aren't perfect"
	$t echo "ERLC_OPTS=+debug_info" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/xfl_lexer.beam
	$t test -f $(APP)/src/xfl_lexer.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xfl_lexer]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the .xrl file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/xfl_lexer.beam \
		$(APP)/src/xfl_lexer.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/src/xfl_lexer.xrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/xfl_lexer.xrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xfl_lexer]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch a .hrl file included directly; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/xfl_lexer.beam \
		$(APP)/src/xfl_lexer.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/src/typechecks.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/typechecks.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xfl_lexer]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch a .hrl file included indirectly; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/xfl_lexer.beam \
		$(APP)/src/xfl_lexer.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/src/errvals.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/errvals.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xfl_lexer]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/boy.erl
	$t test -f $(APP)/src/girl.erl
	$t test -f $(APP)/src/errvals.hrl
	$t test -f $(APP)/src/muin_proc_dict.hrl
	$t test -f $(APP)/src/muin_records.hrl
	$t test -f $(APP)/src/typechecks.hrl
	$t test -f $(APP)/src/xfl_lexer.xrl

	$i "Check that all build artifacts are removed, including intermediates"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/
	$t test ! -e $(APP)/src/xfl_lexer.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/xfl_lexer.beam
	$t test -f $(APP)/src/xfl_lexer.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xfl_lexer]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-yrl: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download .yrl files from Erlang/OTP"
	$t curl -s -o $(APP)/src/xmerl_xpath_parse.yrl $(OTP_MASTER)/lib/xmerl/src/xmerl_xpath_parse.yrl
	$t curl -s -o $(APP)/src/xref_parser.yrl $(OTP_MASTER)/lib/tools/src/xref_parser.yrl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/xmerl_xpath_parse.beam
	$t test -f $(APP)/ebin/xref_parser.beam
	$t test -f $(APP)/src/xmerl_xpath_parse.erl
	$t test -f $(APP)/src/xref_parser.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xmerl_xpath_parse, xref_parser]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .yrl file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/xref_parser.beam \
		$(APP)/src/xref_parser.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/src/xref_parser.yrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/xref_parser.yrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xmerl_xpath_parse, xref_parser]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/boy.erl
	$t test -f $(APP)/src/girl.erl
	$t test -f $(APP)/src/xmerl_xpath_parse.yrl
	$t test -f $(APP)/src/xref_parser.yrl

	$i "Check that all build artifacts are removed, including intermediates"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/
	$t test ! -e $(APP)/src/xmerl_xpath_parse.erl
	$t test ! -e $(APP)/src/xref_parser.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/xmerl_xpath_parse.beam
	$t test -f $(APP)/ebin/xref_parser.beam
	$t test -f $(APP)/src/xmerl_xpath_parse.erl
	$t test -f $(APP)/src/xref_parser.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xmerl_xpath_parse, xref_parser]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-yrl-header: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v
	
	$i "Create a .yrl file"
	$t echo "Nonterminals E T F." > $(APP)/src/y_parse.yrl
	$t echo "Terminals '+' '*' '(' ')' number." >> $(APP)/src/y_parse.yrl
	$t echo "Rootsymbol E." >> $(APP)/src/y_parse.yrl
	$t echo "E -> E '+' T: {'\$$2', '\$$1', '\$$3'}." >> $(APP)/src/y_parse.yrl
	$t echo "E -> T : '\$$1'." >> $(APP)/src/y_parse.yrl
	$t echo "T -> T '*' F: {'\$$2', '\$$1', '\$$3'}." >> $(APP)/src/y_parse.yrl
	$t echo "T -> F : '\$$1'." >> $(APP)/src/y_parse.yrl
	$t echo "F -> '(' E ')' : '\$$2'." >> $(APP)/src/y_parse.yrl
	$t echo "F -> number : '\$$1'. " >> $(APP)/src/y_parse.yrl

	$i "Create the yrl header file"
	$t mkdir $(APP)/include
	$t echo "-export([forty_two/0])." > $(APP)/include/yecc_header.hrl
# A bunch of gobbldygook we don't actually care about, they just
# need to exist so we don't get errors.
	$t echo "-export([yeccpars1/5, yeccerror/1, yeccpars2/7, yeccpars2_0/7, yeccpars2_1/7, yeccpars2_2/7, yeccpars2_3/7, yeccpars2_5/7, yeccpars2_6/7, yeccpars2_7/7, yeccpars2_9/7, yeccpars2_11/7, 'yeccgoto_\'E\''/7, 'yeccgoto_\'F\''/7, 'yeccgoto_\'T\''/7, yeccpars2_9_/1, yeccpars2_11_/1, yeccpars2_7_/1])." >> $(APP)/include/yecc_header.hrl
	$t echo "yeccpars1(_,_,_,_,_) -> throw(not_implemented)." >> $(APP)/include/yecc_header.hrl
	$t echo "yeccerror(_) -> throw(not_implemented)." >> $(APP)/include/yecc_header.hrl
# Required bits done, now part we'll actually test for.
	$t echo "forty_two() -> 42." >> $(APP)/include/yecc_header.hrl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t YRL_ERLC_OPTS="-I include/yecc_header.hrl" $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/y_parse.beam
	$t test -f $(APP)/src/y_parse.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, y_parse]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Check the built yecc module used the header"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		{module, y_parse} = code:load_file(y_parse), \
		42 = y_parse:forty_two(), \
		halt()"

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, y_parse]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-yrl-include: build clean

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download a .yrl file with includes from Erlang/OTP"
	$t curl -s -o $(APP)/src/core_parse.yrl $(OTP_MASTER)/lib/compiler/src/core_parse.yrl
	$t curl -s -o $(APP)/src/core_parse.hrl $(OTP_MASTER)/lib/compiler/src/core_parse.hrl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/core_parse.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/core_parse.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, core_parse, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the .yrl file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/core_parse.beam \
		$(APP)/src/core_parse.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/src/core_parse.yrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/core_parse.yrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, core_parse, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the .hrl file included; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/core_parse.beam \
		$(APP)/src/core_parse.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/src/core_parse.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/core_parse.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, core_parse, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/boy.erl
	$t test -f $(APP)/src/core_parse.hrl
	$t test -f $(APP)/src/core_parse.yrl
	$t test -f $(APP)/src/girl.erl

	$i "Check that all build artifacts are removed, including intermediates"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/
	$t test ! -e $(APP)/src/core_parse.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/core_parse.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/core_parse.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, core_parse, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"
